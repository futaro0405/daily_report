# 2023/09/12日報
## 取り組んだこと
- [プロを目指す人のためのRuby入門](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%92%E7%9B%AE%E6%8C%87%E3%81%99%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AERuby%E5%85%A5%E9%96%80-%E6%94%B9%E8%A8%822%E7%89%88-%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98%E3%81%8B%E3%82%89%E3%83%86%E3%82%B9%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA%E3%83%BB%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E6%8A%80%E6%B3%95%E3%81%BE%E3%81%A7-Software-Design/dp/4297124378/ref=sr_1_1?crid=2KR77SEG3QJJD&keywords=%E3%83%97%E3%83%AD%E3%82%92%E7%9B%AE%E6%8C%87%E3%81%99%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AEruby%E5%85%A5%E9%96%80&qid=1667013521&qu=eyJxc2MiOiIxLjUwIiwicXNhIjoiMS4xNiIsInFzcCI6IjEuMzUifQ%3D%3D&sprefix=%E3%83%97%E3%83%AD%E3%82%92%2Caps%2C372&sr=8-1)を読む

## わかったこと






### 関数や定数を提供するモジュールの作成
#### モジュールに特異メソッドを定義する
わざわざ他のクラスに組み込まなくてもモジュール単体でそのメソッドを呼び出したいケースがある。  
その場合はモジュール自身に特異メソッドを定義すれば、直接`モジュール名.メソッド名`の形でそのメソッドを呼び出すことができる。  
モジュールはクラスと違いインスタンスが作れないため、newする必要がない「単なるメソッド（関数）の集まり」を作りたい場合に向いている。  
モジュールでもクラスと同様に`class << self`を使って、特異メソッドを定義することができる。  
特異メソッドをたくさん定義する場合はメソッド名の前の`self.`がない分、タイプ量を減らすことができる。  

#### `module_function`メソッド
モジュールではミックスインとしても使えて、なおかつモジュールの特異メソッドとしても使えるメソッドを定義する場合は、`module_function`メソッドを使って対象のメソッド名を指定する。  
ちなみに、`module_function`で定義されたメソッドは他のクラスにミックスインすると自動的にprivateになる。  
ミックスインとしても、モジュールの特異メソッドとしても使えるメソッドのことを __モジュール関数__ と呼ぶ。  
`module_function`メソッドを引数なしで呼び出した場合はそこから下で定義されたメソッドは全てモジュール関数になる。  

#### モジュールに定数を定義する
モジュールにも定数を定義することができる。定義の仕方や参照の仕方はクラスの時と同じ。  

#### モジュール関数や定数を持つモジュール例
Mathモジュールのメソッドはモジュール関数になっているため、モジュールの特異メソッドとしても、ミックスインとしても利用できる。  

```
# 自然対数の低を表すE
Math::E
# 円周率を表すPI
Math::PI
```

### 状態を保持するモジュールの作成
クラスインスタンス変数を使ってクラス自身にデータを保持する方法はモジュールでも使うことができる。  
ただし、モジュールはインスタンスできない。インスタンスを作って何か操作をする必要がない場合はモジュールにしたほうがミスを防げる。  

ライブラリの実行に必要な設定値などはアプリケーション全体で共通の値になることが多い。そのため、設定値の情報はアプリケーション内で唯一ひとつだけの状態になっていることが望ましい。  
このように唯一ひとつだけのオブジェクトを作る手法を __シングルトンパターン__ と呼ぶ。  

### 例外の捕捉
#### 発生した例外を捕捉する
何らかの理由で例外が発生してもプログラムを続行したい場合は、例外処理を明示的に書くことでプログラムを続行させることが可能。  

```
begin
  # 例外処理が起きうる処理
rescue
  # 例外処理が発生した場合の処理
end
```

#### 例外処理の流れ
実際のプログラムでは予期しない場所で例外が発生する。例外が発生した箇所がbegin~rescueで囲まれていない場合、そこで処理が中断しメソッドの呼び出しをひとつずつ戻る。  
メソッド呼び出しが戻る途中に例外を捕捉するコードがあれば、そこから処理を続行できる。  

#### 例外オブジェクトから情報を取得
例外オブジェクトのメソッドを呼び出すことで、発生した例外に関する情報を取得することができる。  
代表的なメソッドとして、`message`メソッドと`backtrace`メソッドを使ってみる。  
`message`メソッドは例外発生時のエラーメッセージを返す。`backtrace`メソッドはバックトレース情報を配列で返す。  

```
begin
  1 / 0
rescue => e
  puts "error class: #{e.class}"
  puts "error message: #{e.message}"
  puts e.backtrace
end
```

#### クラスを指定して捕捉する例外を限定する
例外のクラスを指定すると、例外オブジェクトのクラスが一致した場合のみ、例外を捕捉することができる。  

```
begin
  # 例外が起きうる処理
rescue 捕捉したい例外クラス
  # 例外処理が発生した場合の処理
end
```

1つのrescue節に複数の例外クラスを指定することもできる。  

```
begin
  'abc'.foo
rescue ZeroDivisionError, NoMethodError
  puts '0で除算したか存在しないメソッドが呼び出された'
end
```

例外オブジェクトを変数に格納することも可能。  

```
begin
  'abc'.foo
rescue ZeroDivisionError, NoMethodError => e
  puts '0で除算したか存在しないメソッドが呼び出された'
  puts "Error: #{e.class} #{e.message}"
end
```

#### 例外クラスの継承関係を理解する
すべての例外クラスはExceptionクラスを継承している。  
その下に多くの例外クラスがあるが、StandardErrorのサブクラスとそれ以外の例外クラスの違いを理解することができる。  

StandardErrorクラスは通常のプログラムで発生する可能性が高い例外を表すクラスで、StandardErrorクラスを継承していないNoMemoryErrorクラスやSystemExitクラスは通常のプログラムでは発生しない特殊なエラーが発生したことを表す。  
rescue節に何もクラスを指定しなかった場合に捕捉されるのはStandardErrorとそのサブクラスで、StandardErrorを継承していない例外クラスは捕捉されない。  

rescue節に例外クラスを指定した場合、捕捉されるのはそのクラス自身とそのサブクラスになる。  
Exceptionクラスを指定すると、StandardErrorと無関係のエラーまで捕捉することになる。  
しかし、通常プログラムで捕捉するものはStandardErrorクラスか、そのサブクラスに限定すべきだ。  

#### 継承関係とrescue節の順番に注意する
rescue節が複数ある場合、上から順番にrescue節のチェックを行うため、順番に注意しないと永遠に実行されないrescue節ができる。  

#### 例外発生時にもう一度処理をやり直す`retry`
一時的に発生している問題が例外の原因であれば、やり直すことで正常に実行できる可能性がある。  
その場合はrescue節でretry文を実行するとbegin節の最初からやり直すことができる。  

```
begin
  # 例外が起きうる処理
rescue
  retry # 処理をやり直す
end
```

ただし、無条件にretryし続けると例外が解決しない無限ループを作る恐れがある。  
その場合はカウンタ変数を用意して、retryの回数を制限するのがよい。  

### 意図的に例外を発生させる
例外は捕捉するだけでなく、コードの中で意図的に発生させることができる。  
例外を発生させる場合は`raise`メソッドを使う。  

raiseメソッドに文字列を渡すと、その文字列がエラーメッセージになる。  
文字列は省略可能可能ですが、その場合、原因がわかりずらくなるため、通常は原因を特定しやすいメッセージをつける。  
raiseメソッドに文字列だけを渡したときRuntimeErrorクラスの例外が発生する。  
第一引数に例外クラス、第二引数にエラーメッセージを渡すとRuntimeErrorクラス以外の例外クラスで例外を発生させることができる。  

もしくはraiseメソッドに例外クラスのインスタンスを渡す方法がある。  

## 次やること
- [プロを目指す人のためのRuby入門](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%92%E7%9B%AE%E6%8C%87%E3%81%99%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AERuby%E5%85%A5%E9%96%80-%E6%94%B9%E8%A8%822%E7%89%88-%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98%E3%81%8B%E3%82%89%E3%83%86%E3%82%B9%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA%E3%83%BB%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E6%8A%80%E6%B3%95%E3%81%BE%E3%81%A7-Software-Design/dp/4297124378/ref=sr_1_1?crid=2KR77SEG3QJJD&keywords=%E3%83%97%E3%83%AD%E3%82%92%E7%9B%AE%E6%8C%87%E3%81%99%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AEruby%E5%85%A5%E9%96%80&qid=1667013521&qu=eyJxc2MiOiIxLjUwIiwicXNhIjoiMS4xNiIsInFzcCI6IjEuMzUifQ%3D%3D&sprefix=%E3%83%97%E3%83%AD%E3%82%92%2Caps%2C372&sr=8-1)のつづき

## 感じたこと
どのクラスがなんのサブクラスを持っているかをなんとなくでも理解しているとコードを書くときに役に立ちそう（特に例外処理）。  
今後の学習で意識しながら読み進められたらと思う。  

## 学習時間
- TODAY: 4h
- TOTAL: 254h
